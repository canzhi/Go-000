# error

* 三层架构:DAO->业务层->服务层->api/ui,针对异常层层抛出,不可取.

* 通过理解errrors.New(text string) error {} ,理解了类型值等值判断的原理,只是相似,而不是绝对的相等,可以称之为普通相等,只是形状相似,但在内存中存在位置不同;还有个概念交完全相等,这是说明在内存中是唯一的.我们通常说张三在吗,这句话有歧义,如果是自己人可能会知道是说谁;外人可能会问你说哪个张三;所以给自己人声明张三这个人的时候,可以使用普通相等的概念,而给外人声明张三的时候要用完全相等.

* 续上,并且通常error都是要接口的等值判断这就会导致,类型值的普通相等,赋值给接口,可能是这里出现的错误跟那个地方出现的错误竟然想等了,但不能说明这是相同的错误,因为出现的地方不同,一定有不同点的;而用指针型值赋值给接口,这一定是是同一个内存地址的错误才会出现的场景,这才能说明这是说的同一个错误,否则牛头不对马嘴,那还用判断个毛.

* var  Err错误简述 = errors.New("包名:  错误简述")  <-定义(sentinel)哨兵error,包级别

  > 哨兵:计算机中预定义一个值,当程序执行到这,就不要继续执行了.

* bad写法: 没有意义的写法,判断这个没有意义,自定义一个错误类型,放在内存中,永远不可能有操作产出的错误跟你新创建的err相等的.

  ```go
  if err != errors.New("xxx") {
      //handle code
  }
  ```

  

* 所以,我们声明指针都是为了让其对象唯一性,针对这个唯一性的对象,再进行各种后续操作处理.

* errors.New()之所以返回的是地址,是为了防备某种情况下,用户可以自己造个error,竟然蒙对了,相等了.这就嘎纳了.用指针地址,就不会产生这种情况.

* 怎么返回值:1.通过return 2. 通过传入指针,通过对指针的操作,对其内容进行各种操作.

* error的程度是调用函数的人来判断的.写函数的人不用管其重要性.

* panic == fatal error 服务挂掉

* 不要将panic错误抛给调用者,它跟普通error是有区别的.要自己处理.出现panic时,意味着要临时停服务了,而不是提醒调用者一个错误.

* request-driven:根据请求驱动,要用到recover().

* 野生的goroutine: 在go func{}中数组越界,导致线程挂掉,这个其他线程中是recover()不住的.

  一般good 代码保护:异步goroutine的兜底操作,各种想不到的问题.

  ```go
  package async  //声明一个异步goroutine,将异步的gorutine和defer 函数封装起来
  func Go(x func()) {
      defer func(){
          if err != recover(); err != nil {
          	//
      	}
      }()
      go x()
  }
  ```

  ```go
  //调用方法
  async.Go(函数名称)
  ```

  

  更好的操作收法:

  当处理请求时,将要操作的

* 数据库写失败,读可以重连,这时不应panic.可以阻塞,等待一段时间,先不启动其他服务,然后时间到了再启动.否则一直不启动,又会导致其他更多服务等待了.

* blocking grpc强依赖  vs  nonblocking 弱依赖

* 分清true/false  和valid/ not valid

* sentinel error不能携带更多上下文;并且导致依赖,强耦合,后期难改动;

* error type 自定义err类型,可以携带更多上下文;但也是强依赖.

* 二分错误

  ```go
  if err != nil {
      //handle err
  }
  ```

  

* opaque error 不透明error,这是最好的;

* 接口的接口断言:本质是判断接口的里面的值是否具有某种行为.值现在具有某种行为,是否还具有其他行为.

* 对于请求级别的panic,一般会通过recover()返回500错误,返回给用户.

* fmt.Errorf() 当上层不对其进行判断时可以使用,否则很难用到.因为其内容一直在变动.

* errWriter 写法,自带警告信息状态的写入器,相当于写入器变成红色状态.当有err时,红色报警,那么以后其写入方法就会无效,每次其写入方法先判断其状态.err会记录到其内部中.

* 遇到error必须走的步骤:1.return 抛出; 2.  服务降级,把错误吞掉,而不是抛出,比如本该提供一个客户头像,但是访问头像图片报错,此时不应该直接中断头像提供服务,而应该提供一个默认的头像给客户系统,这叫服务降级.

  > 总的来说,必须对返回值负起责任来,不能在存在error的情况下直接使用.

* 日志记录:1.应该记录错误信息; 2.因该记录对调试有帮助的信息,比如I/O操作的输入参数等.3.其他都是噪音,要质疑.4.日志中因该包含某样东西失败的答案.

* 要打日志就不要抛error.要抛error就不要打日志.二选一.建议抛error,但是如何保证error中包含第一次发生地的信息,而不是经过多层传播,后找不到是哪里报的错.如果使用自己的自定义一个type error在每层,又比较复杂.正好用`github.com/pkg/errors`这个包提供了通用的type error使用这个包中的定义的结构体,将底层的err进行封装一些额外信息,可以包含堆栈信息,然后抛给上层调用者,本层的逻辑就不再进行了,因为这是一个比较严重的错误,所以不能什么都不说就在本层自己默默吞掉.`此时return  nil`

* 层层打日志,会导致日志非常乱.

* 通常打日志都在最顶层.

* pkg/errors中还有New/Errorf类似errors.New()和fmt.Errorf()

* pkg/errors使用问题:

  1. 如果调用别人的包中函数(默认别人是在基础库的基础上写的应用层函数,我们写的应用函数跟其实同一层,他们又层层的底层结构,我们也有层层的底层结构),直接透传.不要处理.否则堆栈信息翻倍;

  2. 如果在业务层使用第三方库:本公司基础库,github库,标准库,应该用wrap把根因进行保存.说白了就是最底层的函数

     > 通常底层操作:比如跟mysql/mongodb/grpc/第三方库进行交互的时候.

  3. 在应用(或者在一个goroutine线程)的最顶层(请求的入口),把堆栈信息给打印出来`fmt.Printf`,`%+v`, `errors.Cause(err)`;并可以在这层进行sentinel error比较.

  4. 只有业务应用程序需要wrap,其他的基础库不该wrap.

  5. 具有最高重用性的包不应该被wrap,比如本公司的基础库,很多人来访问,那么写这个库中就不能wrap,否则堆栈翻倍.

  6. 不打算处理错误,那么就是说不准备降级处理.  处理错误==降级.

  7. wrap要包裹足够的信息. 

     > 判断信息已经足够的标准:  通过日志可以直接找到解决问题的答案.
     >
     > 一般把错误和输入参数打印记录到日志就可以排查所有问题了.

  8. errors.Is(err, target)  类似等值判断,err链值中是否有err值是等于sentinel error的.

  9. errors.As(err, &var)  err链值中是否有可以存入到var中的err

* 