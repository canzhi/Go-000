# error

* 三层架构:DAO->业务层->服务层->api/ui,针对异常层层抛出,不可取.

*  通过理解errrors.New(text string) error {} ,理解了类型值等值判断的原理,只是相似,而不是绝对的相等,可以称之为普通相等,只是形状相似,但在内存中存在位置不同;还有个概念交完全相等,这是说明在内存中是唯一的.我们通常说张三在吗,这句话有歧义,如果是自己人可能会知道是说谁;外人可能会问你说哪个张三;所以给自己人声明张三这个人的时候,可以使用普通相等的概念,而给外人声明张三的时候要用完全相等.

* 续上,并且通常error都是要接口的等值判断这就会导致,类型值的普通相等,赋值给接口,可能是这里出现的错误跟那个地方出现的错误竟然想等了,但不能说明这是相同的错误,因为出现的地方不同,一定有不同点的;而用指针型值赋值给接口,这一定是是同一个内存地址的错误才会出现的场景,这才能说明这是说的同一个错误,否则牛头不对马嘴,那还用判断个毛.

* var  Err错误简述 = errors.New("包名:  错误简述")  <-定义(sentinel)哨兵error,包级别

  > 哨兵:计算机中预定义一个值,当程序执行到这,就不要继续执行了.

* bad写法: 没有意义的写法,判断这个没有意义,自定义一个错误类型,放在内存中,永远不可能有操作产出的错误跟你新创建的err相等的.

  ```go
  if err != errors.New("xxx") {
      //handle code
  }
  ```

  

* 所以,我们声明指针都是为了让其对象唯一性,针对这个唯一性的对象,再进行各种后续操作处理.

* errors.New()之所以返回的是地址,是为了防备某种情况下,用户可以自己造个error,竟然蒙对了,相等了.这就嘎纳了.用指针地址,就不会产生这种情况.

* 怎么返回值:1.通过return 2. 通过传入指针,通过对指针的操作,对其内容进行各种操作.

* error的程度是调用函数的人来判断的.写函数的人不用管其重要性.

* panic == fatal error 服务挂掉

* 不要将panic错误抛给调用者,它跟普通error是有区别的.要自己处理.出现panic时,意味着要临时停服务了,而不是提醒调用者一个错误.

* request-driven:根据请求驱动,要用到recover().

* 野生的goroutine: 在go func{}中数组越界,导致线程挂掉,这个其他线程中是recover()不住的.

  一般good 代码保护:异步goroutine的兜底操作,各种想不到的问题.

  ```go
  package async  //声明一个异步goroutine,将异步的gorutine和defer 函数封装起来
  func Go(x func()) {
      defer func(){
          if err != recover(); err != nil {
          	//
      	}
      }()
      go x()
  }
  ```

  ```go
  //调用方法
  async.Go(函数名称)
  ```

  

  更好的操作收法:

  当处理请求时,将要操作的

* 数据库写失败,读可以重连,这时不应panic.可以阻塞,等待一段时间,先不启动其他服务,然后时间到了再启动.否则一直不启动,又会导致其他更多服务等待了.

* blocking grpc强依赖  vs  nonblocking 弱依赖

* 分清true/false  和valid/ not valid

* sentinel error不能携带更多上下文;并且导致依赖,强耦合,后期难改动;

* error type 自定义err类型,可以携带更多上下文;但也是强依赖.

* opaque error 不透明error,这是最好的;

* 接口的接口断言:本质是判断值是否具有某种行为.现在具有某种行为,是否还具有其他行为.

* 